if empty("$XDG_CONFIG_HOME")
	let config_dir = $HOME . '/.config/vim'
else
	let config_dir = $XDG_CONFIG_HOME . '/vim'
endif
if empty("$XDG_DATA_HOME")
	let data_dir = $HOME . '/.local/share/vim'
else
	let data_dir = $XDG_DATA_HOME . '/vim'
endif

call mkdir(data_dir, 'p')

let &runtimepath = &runtimepath . ',' . config_dir . ',' . config_dir . '/after'
let &packpath = &packpath . ',' . config_dir
let &viminfo = &viminfo .  ',n' . data_dir . '/viminfo'

"if ! has('nvim')
    "set rtp^="~/.local/share/vim"
"endif

"source ~/.config/vim/plugins.vim " include plugs"

" default file encoding and unicode
set encoding=utf-8
set fileencoding=utf-8
set fileencodings=utf-8
set bomb                     " vim will put a 'byte order mark' (
                             " or BOM for short) at the start of Unicode files
set fileformats=unix,mac,dos " recognize file formats

set backspace=indent,eol,start " make backspace work like most other apps

" space > tabs
set tabstop=4

set shiftwidth=4
set softtabstop=4
set expandtab " insert space character when tab is pressed
set modeline
set expandtab " helps with backspacing because of expandtab
set textwidth=80

set autoindent
filetype indent on

set autochdir " cwd of vim follows that of opened file in current window

" options

" opening a new file when the current buffer has unsaved changes causes files " to be hidden instead of closed.
" The unsaved changes can still be accessed by typing :ls and then :b[N],
" where [N] is the number of a buffer
" see: http://usevim.com/2012/10/19/vim101-set-hidden/
" set hidden         " don't care about closing modified buffers
set showcmd        " display incomplete commands
set history=50     " keep 50 lines of command line history
nnoremap <SPACE> <Nop>
let mapleader=" "  " use space as mapleader
" set colorcolumn=80 " Color in column 80
set list listchars=tab:»·,trail:·,nbsp:· " Display extra whitespace
set cursorline     " find cursor faster.


               " searching
set hlsearch   " highlight all search matches
set incsearch  " start searching when you type the first character of the search string
set ignorecase " searching is not case sensitive
set smartcase  " when 'ignorecase' and 'smartcase' are both on, if a
               " pattern contains an uppercase letter, it is case sensitive,

               " otherwise, it is not

set gdefault   " sub all matches in a line by default


set binary        " makes Vim more suitable for editing binary files
set shell=/bin/sh " use sh as default shell

" programming
syntax on
set cindent          " enables automatic indenting c-style
set cinoptions=l1,j1 " affects the way cindent reindents lines
set showmatch        " flashes matching brackets or parenthasis
set matchtime=3      " how long to flash brackets

" backups

set nobackup       " don't backup
set nowritebackup  " don't make backup before overwritting
set noswapfile     " fuck swapfiles
set directory=/tmp " dir for tmp files

" jump to the last position when reopening a file
if has("autocmd")
  au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
endif

" info
set number relativenumber
augroup numbertoggle
  autocmd!
  autocmd BufEnter,FocusGained,InsertLeave * set relativenumber
  autocmd BufLeave,FocusLost,InsertEnter   * set norelativenumber
augroup END

set numberwidth=5   " width of number column
set showmode        " shows vi mode in lower left
set cmdheight=1     " more room for error msgs
set scrolloff=4     " places a couple lines between the current line and the screen edge
set sidescrolloff=2 " places a couple lines between the current column and the screen edge
set laststatus=2    " status bar always visible
set ttyfast         " improve redrawing
set lazyredraw      " will not redraw the screen while running macros (goes faster)

if has('linebreak')
  try
    set breakindent             " visually indent wrapped lines
    let &showbreak='↳'

  catch /E518:/

    " Unknown option: breakindent
  endtry

endif


" menu compilation

set wildmenu                    " enhanced ed command completion
set wildignore+=*.~             " ignore compiled objects and backups
set wig+=*.o,*.obj,*.pyc

set wig+=.sass-cache,tmp
set wildmode=longest:full,list:full

" statusline config from -> http://stackoverflow.com/a/5380230/6744969
" GUI
"hi Normal guibg=#262625
"hi User1 guifg=#eea040 guibg=#222222
"hi User2 guifg=#dd3333 guibg=#222222
"hi User3 guifg=#ff66ff guibg=#222222
"hi User4 guifg=#a0ee40 guibg=#222222
"hi User5 guifg=#eeee40 guibg=#222222
" Terminal
"hi Normal ctermbg=8
"hi User1 ctermfg=16
"hi User2 ctermfg=196
"hi User3 ctermfg=171
"hi User4 ctermfg=70
"hi User5 ctermfg=226

if filereadable(expand("~/.vimrc_background"))
  let base16colorspace=256
  source ~/.vimrc_background
else
  colorscheme base16-ocean
endif
let g:lightline = {
\   'colorscheme': 'base16'
\ }

set statusline=
set statusline +=%1*\ %n\ %*            "buffer number
set statusline +=%5*%{&ff}%*            "file format
set statusline +=%3*%y%*                "file type
set statusline +=%4*\ %<%F%*            "full path
set statusline +=%2*%m%*                "modified flag

set statusline +=%1*\ \|%{&fo}\|        "display format-options
set statusline +=%1*%=%5l%*             "current line
set statusline +=%2*/%L%*               "total lines
set statusline +=%1*%4v\ %*             "virtual column number
"set statusline +=%2*0x%04B\ %*          "character under cursor


" keybindings to make life easier
cnoreabbrev W! w!
cnoreabbrev Q! q!
cnoreabbrev Wq wq
cnoreabbrev Wa wa
cnoreabbrev wQ wq
cnoreabbrev WQ wq
cnoreabbrev W w
cnoreabbrev Q q

" Disable arrow keys
noremap <Up> <NOP>
noremap <Down> <NOP>
noremap <Left> <NOP>
noremap <Right> <NOP>

" Windows map
nnoremap <Leader>zh :wincmd h<CR>
nnoremap <Leader>zj :wincmd j<CR>
nnoremap <Leader>zk :wincmd k<CR>
nnoremap <Leader>zl :wincmd l<CR>
nnoremap <Leader>zs :wincmd s<CR>
nnoremap <Leader>zv :wincmd v<CR>
nnoremap <Leader>z> :wincmd ><CR>
nnoremap <Leader>z< :wincmd <<CR>
nnoremap <Leader>z+ :wincmd +<CR>
nnoremap <Leader>z- :wincmd -<CR>
nnoremap <Leader>z= :wincmd =<CR>
nnoremap <Leader>zmm :wincmd o<CR>
nnoremap <Leader>zd :wincmd q<CR>
nnoremap <Leader>zr :wincmd r<CR>

" Delete buffer while keeping window layout (don't close buffer's windows).
" Version 2008-11-18 from http://vim.wikia.com/wiki/VimTip165
if v:version < 700 || exists('loaded_bclose') || &cp
  finish
endif
let loaded_bclose = 1
if !exists('bclose_multiple')
  let bclose_multiple = 1
endif

" Display an error message.
function! s:Warn(msg)
  echohl ErrorMsg
  echomsg a:msg
  echohl NONE
endfunction

" Command ':Bclose' executes ':bd' to delete buffer in current window.
" The window will show the alternate buffer (Ctrl-^) if it exists,
" or the previous buffer (:bp), or a blank buffer if no previous.
" Command ':Bclose!' is the same, but executes ':bd!' (discard changes).
" An optional argument can specify which buffer to close (name or number).
function! s:Bclose(bang, buffer)
  if empty(a:buffer)
    let btarget = bufnr('%')
  elseif a:buffer =~ '^\d\+$'
    let btarget = bufnr(str2nr(a:buffer))
  else
    let btarget = bufnr(a:buffer)
  endif
  if btarget < 0
    call s:Warn('No matching buffer for '.a:buffer)
    return
  endif
  if empty(a:bang) && getbufvar(btarget, '&modified')
    call s:Warn('No write since last change for buffer '.btarget.' (use :Bclose!)')
    return
  endif
  " Numbers of windows that view target buffer which we will delete.
  let wnums = filter(range(1, winnr('$')), 'winbufnr(v:val) == btarget')
  if !g:bclose_multiple && len(wnums) > 1
    call s:Warn('Buffer is in multiple windows (use ":let bclose_multiple=1")')
    return
  endif
  let wcurrent = winnr()
  for w in wnums
    execute w.'wincmd w'
    let prevbuf = bufnr('#')
    if prevbuf > 0 && buflisted(prevbuf) && prevbuf != btarget
      buffer #
    else
      bprevious
    endif
    if btarget == bufnr('%')
      " Numbers of listed buffers which are not the target to be deleted.
      let blisted = filter(range(1, bufnr('$')), 'buflisted(v:val) && v:val != btarget')
      " Listed, not target, and not displayed.
      let bhidden = filter(copy(blisted), 'bufwinnr(v:val) < 0')
      " Take the first buffer, if any (could be more intelligent).
      let bjump = (bhidden + blisted + [-1])[0]
      if bjump > 0
        execute 'buffer '.bjump
      else
        execute 'enew'.a:bang
      endif
    endif
  endfor
  execute 'bdelete'.a:bang.' '.btarget
  execute wcurrent.'wincmd w'
endfunction
command! -bang -complete=buffer -nargs=? Bclose call <SID>Bclose(<q-bang>, <q-args>)
nnoremap <silent> <Leader>bd :Bclose<CR>

" Buffers map
set wildmenu wildcharm=<Tab>
nnoremap <Leader>bb :buffer <Tab>
nnoremap <Leader>bd :Bclose<CR>
nnoremap <Leader>bk :Bclose<CR>
"set wildchar=<Tab> wildmenu wildmode=full
"set wildcharm=<C-Z>
"nnoremap <F10> :b <C-Z>

" File map
nnoremap <Leader>fs :update<CR>
nnoremap <Leader>ff :vi <Tab>
nnoremap <Leader>. :vi <Tab>
nnoremap <Leader>fd :ed .<CR>

" Cursor changes between normal and insert mode
let &t_SI = "\e[6 q"
let &t_EI = "\e[2 q"

" reset the cursor on start (for older versions of vim, usually not required)
augroup myCmds
au!
autocmd VimEnter * silent !echo -ne "\e[2 q"
augroup END


"
" plugs
"

"" incsearch.vim
"map /  <Plug>(incsearch-forward)
"map ?  <Plug>(incsearch-backward)
"map g/ <Plug>(incsearch-stay)

"" vim-easy align
" start interactive EasyAlign in visual mode (e.g. vipga)
xmap ga <Plug>(EasyAlign)

" Start interactive EasyAlign for a motion/text object (e.g. gaip)
nmap ga <Plug>(EasyAlign)

"" Rainbow Parentheses
let g:rainbow_active = 1
au BufRead,BufNewFile *.{md,txt} setlocal textwidth=80

" indentLine
let g:indentLine_setColors = 1

" disable preview window
set completeopt-=preview

" yank to clipboard
if has("win32")
	set clipboard^=unnamed,unnamedplus
elseif has("clipboard")
  set clipboard=unnamed " copy to the system clipboard

  if has("unnamedplus") " X11 support
    set clipboard+=unnamedplus
  endif
endif


if !has('nvim')
  set ttymouse=xterm2
endif

inoremap jk <ESC>
set mouse=a

" WSL yank support
let s:clip = '/mnt/c/Windows/System32/clip.exe'  " change this path according to your mount point
if executable(s:clip)
	augroup WSLYank
		autocmd!
		autocmd TextYankPost * if v:event.operator ==# 'y' | call system(s:clip, @0) | endif
	augroup END
endif

